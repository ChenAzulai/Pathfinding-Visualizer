{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/aStar.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","row","isStart","isFinish","isWall","isVisited","onMouseUp","onMouseDown","onMouseEnter","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","neighbors","filter","neighbor","getUnvisitedNeighbors","prevNode","UP","RIGHT","LEFT","DOWN","UP_RIGHT","DOWN_RIGHT","UP_LEFT","DOWN_LEFT","aStar","totalDistance","heuristicDistance","direction","currNode","currentClosest","i","splice","indexOf","console","log","updateNode","nodeOne","nodeTwo","x1","x2","y1","y2","getDistance","Math","abs","manhattanDistance","distToCompare","path","PathfindingVisualizer","handleSelectChange","event","setState","currentAlgorithm","target","value","handleVisualize","state","visualize","window","alert","mouseIsPressed","pressedNodeType","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","startRow","startCol","finishRow","finishCol","getInitGrid","newGrid","getNewGridStartChanged","getNewGridWithWallToggle","nodesInShortestPath","setTimeout","animateShorterPath","nodeProp","document","getElementById","orderedShortestPath","undefined","getNodesInShortestPath","animate","location","reload","onClick","selected","disabled","href","clean","map","rowInd","nodeInd","handleMouseDown","handleMouseEnter","handleMouseUp","currRow","createNode","slice","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.97d29403.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\nimport './Node.css'\r\n\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n            col,\r\n            row,\r\n            isStart,\r\n            isFinish,\r\n            isVisited,\r\n            isWall,\r\n            onMouseUp,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n        } = this.props;\r\n        const extraClassName =\r\n            isFinish ? 'node-finish'\r\n                : isStart ? 'node-start'\r\n                : isWall ? 'node-wall'\r\n                    : '';\r\n        return (\r\n            <div\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseUp={() => onMouseUp(row,col)}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}/>\r\n        );\r\n    }\r\n}\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {//casting to boolean\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const neighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of neighbors) {\r\n        neighbor.isVisited = true;\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.prevNode = node;\r\n    }\r\n\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPath(finishNode) {\r\n    const orderedShortestPath = [];\r\n    let currNode = finishNode;\r\n    while (currNode !== undefined) {\r\n        orderedShortestPath.push(currNode);\r\n        currNode = currNode.prevNode;\r\n    }\r\n    return orderedShortestPath;\r\n}","const UP = \"up\";\r\nconst RIGHT = \"right\";\r\nconst LEFT = \"left\";\r\nconst DOWN = \"down\";\r\nconst UP_RIGHT = \"up-right\";\r\nconst DOWN_RIGHT = \"down-right\";\r\nconst UP_LEFT = \"up-left\";\r\nconst DOWN_LEFT = \"down-left\";\r\n\r\nexport function aStar(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.totalDistance = 0;\r\n    startNode.direction = UP;\r\n\r\n\r\n    while (!!unvisitedNodes.length) {//casting to boolean\r\n        let currNode = closestNode(grid, unvisitedNodes);\r\n        // sortNodesByDistance(unvisitedNodes);\r\n        // const closestNode = unvisitedNodes.shift();\r\n        // if (currNode.distance === Infinity){\r\n            // return false;\r\n        // }\r\n        currNode.isVisited = true;\r\n        visitedNodesInOrder.push(currNode);\r\n        if (currNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(currNode, grid, finishNode);\r\n    }\r\n}\r\n\r\nfunction closestNode(grid, unvisitedNodes) {\r\n    let currentClosest;\r\n    for (let i = 0; i < unvisitedNodes.length; i++) {\r\n\r\n        if (unvisitedNodes[i].isWall === true) {\r\n            unvisitedNodes.splice(i, 1);\r\n        } else if (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n            currentClosest = unvisitedNodes[i];\r\n        } else if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n            if (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n                currentClosest = unvisitedNodes[i];\r\n            }\r\n        }\r\n    }\r\n    unvisitedNodes.splice(unvisitedNodes.indexOf(currentClosest),1);\r\n    console.log('currNode',currentClosest);\r\n    return currentClosest;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n    const neighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of neighbors) {\r\n        updateNode(node, neighbor, finishNode);\r\n        // neighbor.isVisited = true;\r\n        // neighbor.distance = node.distance + 1;\r\n        // neighbor.prevNode = node;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction updateNode(currNode, neighbor, finishNode) {\r\n    let distance = getDistance(currNode, neighbor);\r\n    if (!neighbor.heuristicDistance) {\r\n        neighbor.heuristicDistance = manhattanDistance(neighbor, finishNode);\r\n    }\r\n    let distToCompare = currNode.distance + distance[0];\r\n    if (distToCompare < neighbor.distance) {\r\n        neighbor.distance = distToCompare;\r\n        neighbor.totalDistance = neighbor.distance + neighbor.heuristicDistance;\r\n        neighbor.prevNode = currNode;\r\n        neighbor.path = distance[1];\r\n        neighbor.direction = distance[2];\r\n    }\r\n}\r\n\r\nfunction getDistance(nodeOne, nodeTwo) {\r\n    const x1 = nodeOne.row;\r\n    const x2 = nodeTwo.row;\r\n    const y1 = nodeOne.col;\r\n    const y2 = nodeTwo.col;\r\n\r\n\r\n    if (x2 < x1 && y1 === y2) {\r\n        if (nodeOne.direction === UP) {\r\n            return [1, [\"f\"], UP];\r\n        } else if (nodeOne.direction === RIGHT) {\r\n            return [2, [\"l\", \"f\"], UP];\r\n        } else if (nodeOne.direction === LEFT) {\r\n            return [2, [\"r\", \"f\"], UP];\r\n        } else if (nodeOne.direction === DOWN) {\r\n            return [3, [\"r\", \"r\", \"f\"], UP];\r\n        } else if (nodeOne.direction === UP_RIGHT) {\r\n            return [1.5, null, UP];\r\n        } else if (nodeOne.direction === DOWN_RIGHT) {\r\n            return [2.5, null, UP];\r\n        } else if (nodeOne.direction === UP_LEFT) {\r\n            return [1.5, null, UP];\r\n        } else if (nodeOne.direction === DOWN_LEFT) {\r\n            return [2.5, null, UP];\r\n        }\r\n    } else if (x2 > x1 && y1 === y2) {\r\n        if (nodeOne.direction === UP) {\r\n            return [3, [\"r\", \"r\", \"f\"], DOWN];\r\n        } else if (nodeOne.direction === RIGHT) {\r\n            return [2, [\"r\", \"f\"], DOWN];\r\n        } else if (nodeOne.direction === LEFT) {\r\n            return [2, [\"l\", \"f\"], DOWN];\r\n        } else if (nodeOne.direction === DOWN) {\r\n            return [1, [\"f\"], DOWN];\r\n        } else if (nodeOne.direction === UP_RIGHT) {\r\n            return [2.5, null, DOWN];\r\n        } else if (nodeOne.direction === DOWN_RIGHT) {\r\n            return [1.5, null, DOWN];\r\n        } else if (nodeOne.direction === UP_LEFT) {\r\n            return [2.5, null, DOWN];\r\n        } else if (nodeOne.direction === DOWN_LEFT) {\r\n            return [1.5, null, DOWN];\r\n        }\r\n    }\r\n    if (y2 < y1 && x1 === x2) {\r\n        if (nodeOne.direction === UP) {\r\n            return [2, [\"l\", \"f\"], LEFT];\r\n        } else if (nodeOne.direction === RIGHT) {\r\n            return [3, [\"l\", \"l\", \"f\"], LEFT];\r\n        } else if (nodeOne.direction === LEFT) {\r\n            return [1, [\"f\"], LEFT];\r\n        } else if (nodeOne.direction === DOWN) {\r\n            return [2, [\"r\", \"f\"], LEFT];\r\n        } else if (nodeOne.direction === UP_RIGHT) {\r\n            return [2.5, null, LEFT];\r\n        } else if (nodeOne.direction === DOWN_RIGHT) {\r\n            return [2.5, null, LEFT];\r\n        } else if (nodeOne.direction === UP_LEFT) {\r\n            return [1.5, null, LEFT];\r\n        } else if (nodeOne.direction === DOWN_LEFT) {\r\n            return [1.5, null, LEFT];\r\n        }\r\n    } else if (y2 > y1 && x1 === x2) {\r\n        if (nodeOne.direction === UP) {\r\n            return [2, [\"r\", \"f\"], RIGHT];\r\n        } else if (nodeOne.direction === RIGHT) {\r\n            return [1, [\"f\"], RIGHT];\r\n        } else if (nodeOne.direction === LEFT) {\r\n            return [3, [\"r\", \"r\", \"f\"], RIGHT];\r\n        } else if (nodeOne.direction === DOWN) {\r\n            return [2, [\"l\", \"f\"], RIGHT];\r\n        } else if (nodeOne.direction === UP_RIGHT) {\r\n            return [1.5, null, RIGHT];\r\n        } else if (nodeOne.direction === DOWN_RIGHT) {\r\n            return [1.5, null, RIGHT];\r\n        } else if (nodeOne.direction === UP_LEFT) {\r\n            return [2.5, null, RIGHT];\r\n        } else if (nodeOne.direction === DOWN_LEFT) {\r\n            return [2.5, null, RIGHT];\r\n        }\r\n    }\r\n}\r\n\r\nfunction manhattanDistance(nodeOne, nodeTwo) {\r\n    const x1 = nodeOne.row;\r\n    const x2 = nodeTwo.row;\r\n    const y1 = nodeOne.col;\r\n    const y2 = nodeTwo.col;\r\n\r\n    return (Math.abs(x1 - x2) + Math.abs(y1 - y2));\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            node.distance = Infinity;\r\n            node.totalDistance = Infinity;\r\n            node.heuristicDistance = null;\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function getNodesInShortestPath(finishNode) {\r\n    const orderedShortestPath = [];\r\n    let currNode = finishNode;\r\n    while (currNode !== undefined) {\r\n        orderedShortestPath.push(currNode);\r\n        currNode = currNode.prevNode;\r\n    }\r\n    return orderedShortestPath;\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node'\r\nimport {dijkstra, getNodesInShortestPath} from '../algorithms/dijkstra'\r\nimport './PathfindingVisualizer.css'\r\n\r\nimport 'react-dropdown/style.css';\r\n\r\n\r\nimport {aStar} from \"../algorithms/aStar\";\r\n\r\n// const startNodeRow = 10;\r\n// const startNodeCol = 15;\r\n// const finishNodeRow = 10;\r\n// const finishNodeCol = 35;\r\n//\r\nconst GRID_LENGTH = 50;\r\nconst GRID_HEIGHT = 20;\r\n\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            currentAlgorithm: '',\r\n            mouseIsPressed: false,\r\n            pressedNodeType: '',\r\n            startNodeRow: 10,\r\n            startNodeCol: 15,\r\n            finishNodeRow: 10,\r\n            finishNodeCol: 35,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const startRow = this.state.startNodeRow;\r\n        const startCol = this.state.startNodeCol;\r\n        const finishRow = this.state.finishNodeRow;\r\n        const finishCol = this.state.finishNodeCol;\r\n        const grid = getInitGrid(startRow, startCol, finishRow, finishCol);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        // console.log('handleMouseDown', row, col);\r\n        // console.log('state', this.state.startNodeRow, this.state.startNodeCol);\r\n        console.log('Down ', this.state.startNodeRow, this.state.startNodeCol, row, col);\r\n\r\n        if (this.state.grid[row][col].isStart) {\r\n            const newGrid = getNewGridStartChanged(this.state.grid, row, col);\r\n            this.setState({grid: newGrid, pressedNodeType: 'start', mouseIsPressed: true});\r\n\r\n        } else {\r\n            const newGrid = getNewGridWithWallToggle(this.state.grid, row, col);\r\n            this.setState({grid: newGrid, mouseIsPressed: true});\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        let newGrid;\r\n        if (this.state.pressedNodeType !== 'start') {\r\n            newGrid = getNewGridWithWallToggle(this.state.grid, row, col);\r\n            this.setState({grid: newGrid});\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        let newGrid;\r\n        if (this.state.pressedNodeType === 'start') {\r\n            newGrid = getNewGridStartChanged(this.state.grid, row, col);\r\n\r\n            this.setState({\r\n                grid: newGrid,\r\n                mouseIsPressed: false,\r\n                pressedNodeType: '',\r\n                startNodeRow: row,\r\n                startNodeCol: col,\r\n            });\r\n\r\n        } else\r\n            this.setState({mouseIsPressed: false});\r\n    }\r\n\r\n    animate(visitedNodesInOrder, nodesInShortestPath) {\r\n\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShorterPath(nodesInShortestPath);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const nodeProp = this.state.grid[node.row][node.col];\r\n                if (!nodeProp.isStart && !nodeProp.isFinish)\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = `node node-visited`;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n\r\n    animateShorterPath(nodesInShortestPath) {\r\n        for (let i = 0; i < nodesInShortestPath.length; i++) {\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPath[i];\r\n                const nodeProp = this.state.grid[node.row][node.col];\r\n                if (!nodeProp.isStart && !nodeProp.isFinish)\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = `node node-shortest-path`;\r\n            }, 15 * i);\r\n        }\r\n    }\r\n\r\n    visualize() {\r\n        const {grid} = this.state;\r\n        let visitedNodesInOrder = [];\r\n        const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\r\n        const finishNode = grid[this.state.finishNodeRow][this.state.finishNodeCol];\r\n        if (this.state.currentAlgorithm === 'Dijkstra')\r\n            visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n        else\r\n            visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n        console.log(visitedNodesInOrder);\r\n        const nodesInShortestPath = getNodesInShortestPath(finishNode);\r\n        this.animate(visitedNodesInOrder, nodesInShortestPath);\r\n    }\r\n\r\n    clean() {\r\n        window.location.reload();\r\n    }\r\n\r\n    handleSelectChange = (event) => {\r\n        this.setState({\r\n            currentAlgorithm: event.target.value\r\n        })\r\n    };\r\n\r\n    handleVisualize = () => {\r\n        console.log('visualize');\r\n        if (this.state.currentAlgorithm === '') {\r\n            window.alert('Choose Algorithm to visualize!');\r\n            return;\r\n        }\r\n        this.visualize();\r\n    };\r\n\r\n    render() {\r\n        const {grid, mouseIsPressed} = this.state;\r\n\r\n        return (\r\n            <>\r\n                <div className=\"toolbar\">\r\n                    <div className=\"dropdown-bar\">\r\n                        <select id=\"dropdown\" onClick={this.handleSelectChange}>\r\n                            <option selected disabled value=\"\">Algorithms</option>\r\n                            <option value=\"Dijkstra\">Dijkstra's Algorithm</option>\r\n                            <option value=\"A*\">A* Search</option>\r\n                        </select>\r\n                    </div>\r\n                    <div className=\"actions-btn\">\r\n                        <ul className=\"nav\">\r\n                            <li id=\"visualize-btn\">\r\n                                <a href=\"#\" onClick={() => {this.handleVisualize()}}>\r\n                                    {this.state.currentAlgorithm === '' ? 'Visualize!' : 'Visualize ' + this.state.currentAlgorithm + '!'}\r\n                                </a>\r\n                            </li>\r\n                            <li id=\"clean-btn\">\r\n                                <a href=\"#\" onClick={() => this.clean()}>\r\n                                    Clear Board\r\n                                </a>\r\n                            </li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n                <div id='mainText'>\r\n                    <ul>\r\n                        <li>\r\n                            <div className=\"start\"/>\r\n                            Start Node\r\n                        </li>\r\n                        <li>\r\n                            <div className=\"target\"/>\r\n                            Target Node\r\n                        </li>\r\n                        <li>\r\n                            <div className=\"unvisited\"/>\r\n                            Unvisited Node\r\n                        </li>\r\n                        <li>\r\n                            <div className=\"visited\"/>\r\n                            Visited Nodes\r\n                        </li>\r\n                        <li>\r\n                            <div className=\"shortest-path\"/>\r\n                            Shortest-path Node\r\n                        </li>\r\n                        <li>\r\n                            <div className=\"wall\"/>\r\n                            Wall Node\r\n                        </li>\r\n                    </ul>\r\n                </div>\r\n                <div id=\"algorithmDescriptor\">To set a wall, select and drag the mouse over the nodes.</div>\r\n\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowInd) => {\r\n                        return (<div key={rowInd}>\r\n                                {row.map((node, nodeInd) => {\r\n                                    const {col, row, isStart, isFinish, isWall, isVisited} = node;\r\n                                    return (\r\n                                        <Node key={nodeInd}\r\n                                              col={col}\r\n                                              row={row}\r\n                                              isStart={isStart}\r\n                                              isFinish={isFinish}\r\n                                              isVisited={isVisited}\r\n                                              isWall={isWall}\r\n                                              mouseIsPressed={mouseIsPressed}\r\n                                              onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                              onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                              onMouseUp={() => this.handleMouseUp(row, col)}\r\n                                        >\r\n                                        </Node>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nconst getInitGrid = (startRow, startCol, finishRow, finishCol) => {\r\n\r\n    const grid = [];\r\n    for (let row = 0; row < GRID_HEIGHT; row++) {\r\n        const currRow = [];\r\n        for (let col = 0; col < GRID_LENGTH; col++) {\r\n            currRow.push(createNode(col, row, startRow, startCol, finishRow, finishCol));\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\n\r\nconst createNode = (col, row, startRow, startCol, finishRow, finishCol) => {\r\n\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === startRow && col === startCol,\r\n        isFinish: row === finishRow && col === finishCol,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n    };\r\n};\r\n\r\n\r\nconst getNewGridWithWallToggle = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridStartChanged = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isStart: !node.isStart,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n","import './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nimport React from \"react\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <App/>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}